<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Array Cardio üí™</title>
</head>
<body>
  <p><em>Psst: have a look at the JavaScript Console</em> üíÅ</p>
  <script>
    // Get your shorts on - this is an array workout!
    // ## Array Cardio Day 1

    // Some data we can work with

    const inventors = [ // each element in this array is an object. each object has 4 members. 
      { first: 'Albert', last: 'Einstein', year: 1879, passed: 1955 },
      { first: 'Isaac', last: 'Newton', year: 1643, passed: 1727 },
      { first: 'Galileo', last: 'Galilei', year: 1564, passed: 1642 },
      { first: 'Marie', last: 'Curie', year: 1867, passed: 1934 },
      { first: 'Johannes', last: 'Kepler', year: 1571, passed: 1630 },
      { first: 'Nicolaus', last: 'Copernicus', year: 1473, passed: 1543 },
      { first: 'Max', last: 'Planck', year: 1858, passed: 1947 },
      { first: 'Katherine', last: 'Blodgett', year: 1898, passed: 1979 },
      { first: 'Ada', last: 'Lovelace', year: 1815, passed: 1852 },
      { first: 'Sarah E.', last: 'Goode', year: 1855, passed: 1905 },
      { first: 'Lise', last: 'Meitner', year: 1878, passed: 1968 },
      { first: 'Hanna', last: 'Hammarstr√∂m', year: 1829, passed: 1909 }
    ];

    const people = [ // each element in this array is a string. 
      'Bernhard, Sandra', 'Bethea, Erin', 'Becker, Carl', 'Bentsen, Lloyd', 'Beckett, Samuel', 'Blake, William', 'Berger, Ric', 'Beddoes, Mick', 'Beethoven, Ludwig',
      'Belloc, Hilaire', 'Begin, Menachem', 'Bellow, Saul', 'Benchley, Robert', 'Blair, Robert', 'Benenson, Peter', 'Benjamin, Walter', 'Berlin, Irving',
      'Benn, Tony', 'Benson, Leana', 'Bent, Silas', 'Berle, Milton', 'Berry, Halle', 'Biko, Steve', 'Beck, Glenn', 'Bergman, Ingmar', 'Black, Elk', 'Berio, Luciano',
      'Berne, Eric', 'Berra, Yogi', 'Berry, Wendell', 'Bevan, Aneurin', 'Ben-Gurion, David', 'Bevel, Ken', 'Biden, Joseph', 'Bennington, Chester', 'Bierce, Ambrose',
      'Billings, Josh', 'Birrell, Augustine', 'Blair, Tony', 'Beecher, Henry', 'Biondo, Frank'
    ];
    
    /* 
    these array methods are useful bc when you apply them, it will loop through the entire array. it will do something on 
    each item/element in your array. compared to the traditional for loop:

    for (let i = 0; i <= array.length; i++) {
      your code for what to do to each array[i]
    };

    with these methods, you don't need to write the above block to iterate through each array item. the method does all that and
    depending on which method you choose, you can either filter, map or sort etc.

    */

    // Array.prototype.filter()
    // 1. Filter the list of inventors for those who were born in the 1500's

    const fifteen = inventors.filter(function(anything) {  // inventors.filter is the inventors array using the filter method. 
      // inside the filter() is a function acting as the param/var. this function will loop through the entire array. and the function
      // receives (anything). you can name this whatever you want, in the video he names it inventor. that (anything) is each element
      // in the inventors array. and for each element, we can then decide if we want to keep it or not
      if (anything.year >= 1500 && anything.year <= 1599) { // check if each element's year is in the 1500s
        return true; // keep it if 1500s
      } // else {  // you don't need the else. bc for those that don't match the if part, it will be discarded
        // return false; // don't keep it if not 1500s
      // }
      
    });

    console.log(fifteen); // show the results but it is in a collapsible format which you have to click to show more details
    console.table(fifteen); // show in a table. easier to read

    // line 54, you can do an arrow function. it will look like this: 
    // inventors.filter(anything => {
        // if (anything.year >= 1500 && anything.year <= 1599) {
          // return true;
        // }
    // });

    // Array.prototype.map()
    // 2. Give us an array of the inventors first and last names

    // map takes an array and returns a new array with the same length. if an array has 5 items/elements, then map will do something
    // to each element/item and you will get back 5 items. he gives a factory analogy. map takes a widget and stamps something on it 
    // and returns that widget at the end of the assembly line. whereas filter can take in 10 things and return 2, map will return 
    // the same amount of items that you give it.

    const fullNames = inventors.map(theThing => { // arrow function on multiple lines. inventors is the array. and theThing is 
      // what you are calling each item/element in the array. you can call it whatever you want. his video uses inventor. 
      return `${theThing.first} ${theThing.last}`; // when you leave out return, nothing happens bc a function has to return 
      // something. if you had console.log instead of return, then the map will show each first and last name as it goes 
      // through the array. also, with return there, it sends the result to const fullNames bc that is what is calling the map
      // method/function. now that const fullNames has the results, it won't show it until you console log it.
    });

    console.log(fullNames);

    // const fullNames = inventors.map(theThing => (`${theThing.first} ${theThing.last}`)); the arrow function on one line doesn't
    // need a return and also doesn't need the { }. but you will still need the console.log in order to see the results of the map

    // Array.prototype.sort()
    // 3. Sort the inventors by birthdate, oldest to youngest

    // the way sort works is you get two items and you sort those two items. it will look at person A and B. if A is older, then
    // it puts A on top. and it returns a 1 and -1. then it will bubble these items up and down in the array.

    const ordered = inventors.sort(function(firstPerson, secondPerson){ // const ordered holds the results of the sort method. 
      //it is using a function as a param/var. the two params are person A and B
      if (firstPerson.year > secondPerson.year) { // if person A is born after person B, then it returns a 1. if false, then returns a -1.
        return 1; // this makes person A go down the list. if you change it to -1, then this goes up the list
      } else {
        return -1; // this makes person B go up the list. if you change it to 1, then this goes down the list
      } 
    }); // the newer year is pushed down the list and the older years are pushed up. so the sort is oldest year to newest year.
    // to make it sort newest year to oldest year, going backwards, then change the 1 and -1.

    // unsure how this works, but it does sort properly. better learn how to step through so you can see what happens at each 
    // iteration going through the array

    // one way to think of the sort and return -1 and 1. imagine the array is a horizontal, reading from left to right.
    // and each time -1 is returned, it pushes that item to the left. and each time 1 is returned it pushes it to the right. 
    // so the sort will go through the entire array of items and keep pushing things to the left or right and this results in 
    // an order of lowest to highest or highest to lowest along the horizontal.

    console.table(ordered);

    // be careful with sort bc it treats numbers as strings so the default behavior would show 1, 100, 2, 3, 33333, 4 as an 
    // ascending sort of numbers bc 100 is viewed as less than 2 when it is a string. same as 33333 is less than 4 when it is a
    // string. to avoid this behavior, use something like this:
    // function compareNumbers(a, b) {
    //   return a - b;  
    // }

    // or like this: items.sort((a, b) => a.value - b.value);
    // this is similar to the idea of if a > b, return 1. else -1. the a - b part will sort numbers in ascending order. and even 
    // if strings and numbers are together, it will sort them as numbers. so it will look like this:

    // 1, 5, '7', 8, '10', 15, '20', 30

    // Array.prototype.reduce()
    // 4. How many years did all the inventors live all together?
    
    // he explains reduce by differentiating it from map, filter and sort. previous methods take an item in and either sort, map
    // or filter them. reduce allows you to build something on every single item that it receives. 
     
    // a reduce is a cleaner way to do the loop below. this is an ex of a common loop on an array that accumulates values

    let totalYears = 0;
    for(let i = 0; i < inventors.length; i++) {
      console.log(inventors[i].year); // it prints out from oldest year to highest year instead of the order of the items in the 
      // array such as 0, 1, 2, 3, .... 11. if you comment out the sort method at line 103, then when you run this loop, the years
      // will show not in oldest to newest years but by the index position number such as 0, 1, 2, 3, ... 11.
      totalYears += inventors[i].year;
    }
    // this will go through the inventors array and print each year as it iterates through the loop. it also accumulates the 
    // years as a sum. then after the loop is done, it will print the sum
    console.log(totalYears);

    // reduce will give you a running total or what you've returned from the last time around. he names the prevVal as total. 
    // and he also wants to get the inventor so he names the second param/var currVal as inventor
    const totalYearsReduce = inventors.reduce((prevVal, currVal) => {
      return prevVal + (currVal.passed - currVal.year); // return total + {the years lived} is done at each iteration of the loop.
      // reduce is similar to map, ordered, filtered in that it will loop through each element/item of the array. it won't skip any.
      // this will go to an item and do the math of (passed - year) to get the years lived. then it adds it to total. then it does 
      // it again to the second item in the array. then again to the third item in the array and won't skip any items until it 
      // reaches the length of the array aka the last item. then it returns the accumulated total to the const totalYearsReduce
    }, 0); // this 0 here is initializing the total var with 0. then after each iteration, the 0 increases by the years lived

    // in a single line: reduce((previousValue, currentValue) => { /* ‚Ä¶ */ } , initialValue)
    // his video is like this: reduce((total, inventor) => {total + (inventor.passed - inventor.year)}, 0)
                                  // (prevVal, currVal) => {prevVal + (currVal's from array)}, initial value for prevVal 

    console.log(totalYearsReduce); 
    
    // at line 163, it used to look like this: }); without a 0 which is the usual way to end an arrow function. but that will 
    // give you in the console.log [object Object]7859843780508967907681. this is unusual bc the first time around the loop, 
    // the total is undefined. to fix it, he goes to the end of the arrow function and makes it look like this: }, 0);
    // that fixes it bc it defines total with 0 and then the loop fills in the total correctly.

    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#how_reduce_works_with_an_initial_value
    // the reduce ex in his video is very close to the example paragraph on "How reduce works with an initial value". 
    
    // [15, 16, 17, 18, 19].reduce(
    //   (previousValue, currentValue) => previousValue + currentValue, 
    //   10,
    // ); // this in a single line: reduce((previousValue, currentValue) => { /* ‚Ä¶ */ } , initialValue)
    
    // 5. Sort the inventors by years lived

    // this sort is very similar to the sort at line 103. instead of just comparing year, we are comparing the years lived
    // which is passed minus year. 
    const oldest = inventors.sort(function(firstPerson, secondPerson){
      const lastGuy = firstPerson.passed - firstPerson.year;
      const nextGuy = secondPerson.passed - secondPerson.year;
      if (lastGuy > nextGuy) {
        return -1;  // last sort on line 103 had 1 and then -1. which is ascending order, lowest to highest. this one has 
        // -1 and then 1 which is descending order, highest to lowest.
      } else {
        return 1;
      }
    });

    // one way to think of the sort and return -1 and 1. imagine the array is a horizontal, reading from left to right.
    // and each time -1 is returned, it pushes that item to the left. and each time 1 is returned it pushes it to the right. 
    // so the sort will go through the entire array of items and keep pushing things to the left or right and this results in 
    // an order of lowest to highest or highest to lowest along the horizontal.

    console.table(oldest);

    // 6. create a list of Boulevards in Paris that contain 'de' anywhere in the name
    // https://en.wikipedia.org/wiki/Category:Boulevards_in_Paris

    /* the page lists a lot of boulevard names. we need to get the ones that have "de" in the name. we need to get the dom elements 
    out of the page. find a boulevard name and inspect element. you'll see that <div class = "mw-category mw-category-columns"> is 
    holding all the boulevard names. now we can use this for our querySelector

    const category = document.querySelector(".mw-category"); // this gets the class mw-category
    const links = category.querySelectorAll("a"); // this gets all a's which are the links inside the class mw-category

    you can write const category to include the class and links together instead of with two lines: 
    const category = document.querySelectorAll(".mw-category a"); this will give you a node list of all the links inside the 
    class mw-category  

    in the console, type category; and links; and you can see the dom elements and the node list of the links. there will be 39 
    links. these are the links inside that div section of class mw-category. next he shows how to convert the list of links to a
    list of names. then to filter only those street names that have "de" in the name. 

    const de = links.map(anyThing => {
      return anyThing.textContent;
    }); 

    when you do the above, you'll get this error Uncaught TypeError: links.map is not a function at <anonymous>:1:18. that's bc
    the node list doesn't have map available for it. remember node list is array-like but not a real array so it won't 
    have all the array methods available for it. and when you click on the [[Prototype]]:NodeList you'll see there is no map. but
    there is a forEach. a forEach will work here but instead of using forEach, he will change the node list into a real array. 

    you can wrap it inside of Array.from(). so it will look like this:
    const links = Array.from(category.querySelectorAll("a")); this makes your node list from array-like to a real array and you can 
    now use map and more methods instead of being limited to just forEach.

    another way is to use spread. this takes your node list and spreads every item into an array. a spread takes every item out 
    of something, an iterable, in this case it is a node list. and then puts it into an array. 
    const links = [...category.querySelectorAll("a")]; this is using spread notation

    putting it altogether:
    const category = document.querySelector(".mw-category");
    const links = Array.from(category.querySelectorAll("a"));  or const links = [...category.querySelectorAll("a")];
    

    const de = links.map(anyThing => {
      return anyThing.textContent; // be sure to have return or else it won't work. if you have your arrow function in one line, 
      // then you don't need return and { }
    });

    const de = links.map(anyThing => anyThing.textContent); // when your arrow function is one line, no need for return and no 
    // need for { }

    before adding the filter, if you just stopped after map, then you will see 39 items of your array with the street names

    after map takes each array element and gets the street name, next you want to filter those street names that have "de".
    put const de = links on one line and each method below it.
      .map etc
      .filter etc

    it will now look like this:
    const de = links
      .map(anyThing => {
        return anyThing.textContent;
      })  // be sure to leave out ; here. 
      .filter(anyStreet => {
      return anyStreet.includes("de");
    }); // you only want ; at the end of this whole thing.

    when you type de; you will see that there are only 12 items in your array now. that's bc the original 39 items which were 
    all the street names are now filtered down to 12 bc only those 12 have "de" in the name.

    */

    
    // 7. sort Exercise
    // Sort the people alphabetically by last name

    const alpha = people.sort(function(lastOne, nextOne) {
      console.log(lastOne); // shows the sort as a list in the order of the array. there is no actual sorting of ascending or 
      // descending bc it is only on lastOne. when lastOne and nextOne are used, then it will do the comparison and sort 
      // alphabetically
    });

    const alpha2 = people.sort(function(lastOne, nextOne){
      const parts = lastOne.split(", "); // each item in the array has last name, first name. so using split will make each item
      // into its own array where the first item is the last name and the second item is the first name
      console.log(parts);
    });

    // const people = ['Bethea, Erin', 'Becker, Carl', 'Bentsen, Lloyd']. using .split(", ") will take the string 'Bethea, Erin'
    // and make it into two parts. Bethea and Erin. and these two parts are now an array with Bethea as item 0 and Erin as item 1.
    // the split will do it to all the names in the people array. so when you console.log(parts), it will show
    // 'Bethea, Erin' string becomes ['Bethea', 'Erin'] array
    // 'Becker, Carl' string becomes ['Becker', 'Carl'] array
    // 'Bentsen, Lloyd' string becomes ['Bentsen', 'Lloyd'] array


    const alpha3 = people.sort(function(lastOne, nextOne) {
      const [last, first] = lastOne.split(", "); // using const [last, first], this will take the split items and change it from 
      // ["last name", "first name"] which had each name as its own array, to "lastname first name" where the entire name is a
      // single variable instead of an array consisting of two items
      console.log(typeof [last, first]); // shows object
      console.log(last, first); // shows the name as last first without the comma. the comma is not part of the string. it is for 
      // separating the index 0 and index 1 when destructuring the array items into a single variable. in this case, string.
      console.log(typeof (last, first)); // shows string for the full name
      console.log(typeof last, typeof first); // shows string string for each part of the full name
    });

    // notice line 286 and 300 are almost the same. 286 has const parts = lastOne.split(", ")
    // 300 has const [last, first] = lastOne.split(", "). instead of parts as the var name, it is using [last, first]. it looks
    // like an array but it is not. it is actually a string. he calls it destructure the array. it takes the array and makes it 
    // into a string. the array items are unpacked and the const [last, first] means it is taking index 0 and index 1 and putting
    // it together. you can do const [any, anyOther]. all this means is it reads from left to right in the array. so it will always
    // grab index 0 and index 1. if you wanted to grab other index numbers then it would look like this const [first,,,last].
    // this means the array has 4 items. and the [first,,,last] is getting index 0, then skipping index 1 and 2 and then getting 
    // index 3.
    // ['Bethea', 'Erin'] array becomes 'Bethea Erin' string
    // ['Becker', 'Carl'] array becomes 'Becker Carl' string
    // ['Bentsen', 'Lloyd'] array becomes 'Bentsen Lloyd' string. 

    // alpha3 is only doing this for lastOne, we need to do this for nextOne so the sort can do a comparison and order the names
    // alphabetically

    const alpha4 = people.sort(function(lastOne, nextOne) {
      const [firstPersonLastName, firstPersonFirstName] = lastOne.split(", ");
      const [secondPersonLastName, secondPersonFirstName] = nextOne.split(", ");
      if (firstPersonLastName > secondPersonLastName) { // we only need to sort on the last name
        return 1; // if the first person's last name is a higher letter, then the 1 will increase the index number position
      } else {
        return -1; // if the first person's last name is a lower letter, then the -1 will decrease the index number posiition
      } // the 1 and -1 moves the items up and down the array to show the sort properly
    });

    console.log(alpha4); // shows all the items in alphabetic order by the last name. interestingly, this list shows Bernhard Sandra.
    // before alpha4, Bernard Sandra didn't show up. maybe bc the sort needs 2 items for the comparison and when you did 
    // the sort in alpha1 to alpha3, it didn't use two items to compare. did it ignore the very first item which is 
    // Bernhard Sandra and started to show the list starting with the second item?

    // 8. Reduce Exercise
    // Sum up the instances of each of these
    const data = ['car', 'car', 'truck', 'truck', 'bike', 'walk', 'car', 'van', 'bike', 'walk', 'car', 'van', 'car', 'truck',
  'pogo stick', 'pogo stick', 'lines', 'lines', 'newThing', 'anotherNewThing', 'newThing', 'anotherNewThing', 'anotherNewThing',
   'newThing' ];

    // reduce is one of the most flexible methods available to arrays. 

    /* 

    
    const transportation = data.reduce(function(objectToCount, itemInArray) {
        // code to count each object and accumulate the totals
    }, {
      car: 0, // like the previous reduce, you'll need to initialize a starting value while you accumulate the totals for each
      // object. but you won't know all the objects before hand and to hard code them is not a good idea since they can change.
      // so before we can identify the object, he shows an ex of a blank object.
      walk: 0,
      truck: 0
    });

    */

    // the same code as above but instead of hard coding the objects for the initial values, here is a blank object 

    const transportation = data.reduce(function(objectToCount, itemInArray) {
      console.log(itemInArray);  // shows all the items in our array
      return objectToCount; // this returns a blank object to const transportation for now

    }, { }); // blank object

    console.log(transportation); // when you show transportation at this point, the console shows { } as a blank object bc
    // we haven't filled up the objects yet

    /* 

    const transportationFillingObjects = data.reduce(function(objectToCount, itemInArray) {
      objectToCount[itemInArray]++; //  if there was a walk, then this will increment the walk below from 0 to 1
      return objectToCount;
    }, { 
      walk: 0; // but we still don't know if walk exists. if walk doesn't exist, then we can keep it at 0 and check for 
      // the next object.
    });

    */

    const transportationFillObjects = data.reduce(function(objectToCount, itemInArray) {
      if (!objectToCount[itemInArray]) { // since we won't know which objects exist, this line checks for the opposite of it
      // existing. if it doesn't exist, then it sets the new object it just found equal to zero which will fill our formerly 
      // blank object with something in line 395
        objectToCount[itemInArray] = 0;
      }

      objectToCount[itemInArray]++; // now that it has found objects, it will increment the count by 1. 
      return objectToCount; // this will return a list of objects with their counts to the const transportationFillObjects
    }, { }); // start with the blank object. and will fill up with new objects it finds. also line 393 increments each object count 
    // by 1

    console.log(transportationFillObjects); // this will show the object with each item and the count of each item

    // with reduce, you need an initial value for the first param objectToCount. you can think of the first param as the accumulator
    // and also as the prev Val as it iterates through the array. so basically it starts with this prev Val and each array's items
    // is added to it and that first param keeps growing. the second param itemInArray is taken from the items in the 
    // const data array. since objectToCount needs that initial value and we don't know it yet, that is why he uses the 
    // if (!objectToCount[itemInArray]) to give it a value of 0 for those that don't exist. and now that the empty object 
    // has something in it, we can increment it with each instance from our array

    // first start with a blank object. that is line 395. then each iteration of the loop, see if there is an entry for that. and 
    // if not, then we need to make an entry and give it zero. then increment the count of it, so now that it exists in our formerly 
    // blank object. and this will keep going through the array until it reaches the end. 

    // the good thing about reduce and having this (!objectToCount[itemInArray]), is when a new item in the array is added, the 
    // reduce will capture that as well. so it's dynamic.
    

  </script>
</body>
</html>
